#![allow(clippy::disallowed_macros)]
use build_shared::write_if_file_changed;
use std::collections::HashMap;
use std::fs;

pub mod build_shared;

fn to_snakecase(s: &str) -> String {
    let mut output = String::new();
    for c in s.chars() {
        if c.is_ascii_uppercase() {
            if output.len() > 0 {
                output.push('_');
            }
        }
        output.push(c.to_ascii_lowercase());
    }
    output
}

fn build_knowledge() {
    println!("cargo:rerun-if-changed=src/messages/components.rs");

    // table name: indexed
    let mut achievement_table: Vec<String> = Vec::new();

    // knowledge type, component name
    let mut knowledge_table: HashMap<String, i32> = HashMap::new();

    // 1. Read GameState/mod.rs, parse all tables
    let input = fs::read_to_string("src/messages/components.rs").unwrap();

    let lines: Vec<&str> = input.split('\n').collect();
    let mut next_struct_is_table = false;
    let mut achievement = false;
    let mut knowledge_type = 0;

    for line in lines {
        if line.trim().contains("#[") {
            if line.to_ascii_lowercase().contains("spacetimedb::table") {
                next_struct_is_table = true;
            }
            achievement |= line.to_ascii_lowercase().contains("achievement");

            if line.to_ascii_lowercase().contains("knowledge_entity") {
                knowledge_type = 2;
            } else if line.to_ascii_lowercase().contains("knowledge_location") {
                knowledge_type = 3;
            } else if line.to_ascii_lowercase().contains("knowledge_recipe") {
                knowledge_type = 4;
            } else if line.to_ascii_lowercase().contains("knowledge_on_acquire_callback") {
                knowledge_type = 5;
            } else if line.to_ascii_lowercase().contains("knowledge") {
                knowledge_type = 1;
            } else {
                knowledge_type = 0;
            }

            continue;
        }

        if line.contains("pub struct") {
            if next_struct_is_table {
                next_struct_is_table = false;

                if let Some(name_index) = line.find("pub struct ") {
                    let start = name_index + 11;
                    let line = &line[start..];

                    if let Some(index) = line.find(" ") {
                        let name = &line[..index].to_string();

                        if achievement {
                            achievement_table.push(name.clone());
                        }
                        if knowledge_type > 0 {
                            // knowledge or knowledge_entity
                            knowledge_table.insert(name.clone(), knowledge_type);
                        }
                    }
                };
            }
        }

        achievement = false;
    }

    let mut output_includes = String::new();
    let mut output_discovery = String::new();
    let mut output_init = String::new();
    let mut output_commit = String::new();
    let mut output_functions = String::new();
    let mut output_generate_knowledges = String::new();

    let mut sorted_keys: Vec<String> = knowledge_table.clone().into_keys().collect();
    sorted_keys.sort();

    output_includes.push_str("//This file is auto-generated by bitcraft\\build.rs. Do not edit.\n\n");

    output_includes.push_str("use spacetimedb::{ReducerContext, Table};\n");
    output_includes.push_str("use crate::game::discovery::Discovery;\n");

    output_discovery.push_str("//This file is auto-generated by bitcraft\\build.rs. Do not edit.\n\n");

    output_discovery.push_str("use spacetimedb::{ReducerContext, Table};\n");
    output_discovery.push_str(
        "use crate::{game::{discovery::Discovery, coordinates::OffsetCoordinatesSmall}, messages::{components::*, static_data::*}};\n",
    );

    for k in &sorted_keys {
        output_discovery.push_str(format!("use crate::messages::components::{};\n", k).as_str());
    }

    output_discovery.push_str("\n\npub struct Knowledges {\n");

    output_init.push_str("#[allow(dead_code)]\n");
    output_init.push_str("impl Discovery {\n\n");
    output_init.push_str("    pub fn initialize(&mut self, ctx: &ReducerContext) {\n");
    output_init.push_str("        let player_entity_id = self.player_entity_id;\n");
    output_init.push_str("        self.knowledges = Some(Knowledges {\n");

    output_commit.push_str("    pub fn commit(&mut self, ctx: &ReducerContext) {\n");
    output_commit.push_str("        if self.knowledges.is_none() {\n");
    output_commit.push_str("            return;\n");
    output_commit.push_str("        }\n\n");
    output_commit.push_str("        self.on_knowledge_acquired(ctx);\n\n");
    output_commit.push_str("        let knowledges = self.knowledges.as_mut().unwrap();\n\n");
    output_commit.push_str("        let player_entity_id = self.player_entity_id;\n\n");

    output_generate_knowledges.push_str("pub fn generate_knowledges(ctx: &ReducerContext, entity_id: u64) {\n");

    for k in sorted_keys {
        let v = knowledge_table[&k].clone();

        let is_entity = v == 2;
        let is_location = v == 3;
        let is_recipe = v == 4;
        let has_callback = v == 5;
        let has_achievement = achievement_table.contains(&k);

        //KnowledgeBattleActionState => battle_action
        let n = k.strip_prefix("Knowledge").unwrap();
        let n = n.strip_suffix("State").unwrap();
        let n = to_snakecase(n);
        let n = n.as_str();

        let id;
        let id_type;
        let suffix;
        let entry_type;
        let hash_function;
        let cmp;

        if is_entity {
            id = format!("{}_entity_id", n);
            suffix = ": u64";
            id_type = "entity_id";
            entry_type = "KnowledgeEntityEntry";
            hash_function = "entity_entry_array_hash";
            cmp = format!("e.{} == {}", id_type, id);
        } else if is_location {
            id = "coordinates".to_string();
            suffix = ": OffsetCoordinatesSmall";
            id_type = "location_hash";
            entry_type = "KnowledgeLocationEntry";
            hash_function = "location_entry_array_hash";
            cmp = "e.location == coordinates".into();
        } else {
            id = format!("{}_id", n);
            suffix = ": i32";
            id_type = "id";
            entry_type = "KnowledgeEntry";
            hash_function = "knowledge_entry_array_hash";
            cmp = format!("e.{} == {}", id_type, id);
        }

        output_functions.push_str(
            format!(
                "    pub fn already_discovered_{}(ctx: &ReducerContext, player_entity_id: u64, {}{}) -> bool {{\n",
                n, id, suffix
            )
            .as_str(),
        );
        output_functions.push_str(
            format!(
                "        if let Some(knowledge) = ctx.db.{}().entity_id().find(player_entity_id) {{\n",
                camel_to_snake(&k)
            )
            .as_str(),
        );
        output_functions.push_str(format!("            if let Some(_entry) = knowledge.entries.iter().find(|e| {}) {{\n", cmp).as_str());
        output_functions.push_str("                // acquired or discovered means discovered\n");
        output_functions.push_str("                return true;\n");
        output_functions.push_str("            }\n");
        output_functions.push_str("        }\n");
        output_functions.push_str("        false\n");
        output_functions.push_str("    }\n\n");

        output_functions.push_str(
            format!(
                "    pub fn already_acquired_{}(ctx: &ReducerContext, player_entity_id: u64, {}{}) -> bool {{\n",
                n, id, suffix
            )
            .as_str(),
        );
        output_functions.push_str(
            format!(
                "        if let Some(knowledge) = ctx.db.{}().entity_id().find(player_entity_id) {{\n",
                camel_to_snake(&k)
            )
            .as_str(),
        );
        output_functions.push_str(format!("            if let Some(entry) = knowledge.entries.iter().find(|e| {}) {{\n", cmp).as_str());
        output_functions.push_str("                // acquired or discovered means discovered\n");
        output_functions.push_str("                return entry.state == KnowledgeState::Acquired;\n");
        output_functions.push_str("            }\n");
        output_functions.push_str("        }\n");
        output_functions.push_str("        false\n");
        output_functions.push_str("    }\n\n");

        // discovery has_discovered
        output_functions.push_str(format!("    pub fn has_discovered_{}(&self, {}{}) -> bool {{\n", n, id, suffix).as_str());
        output_functions.push_str("        // This should only be used internally if any change was found in the knowledges, therefore knowledges should yield a value.\n");
        output_functions.push_str("        if let Some(knowledges) = &self.knowledges {\n");
        output_functions.push_str(format!("            return knowledges.knowledge_{}.iter().any(|e| {});\n", n, cmp).as_str());
        output_functions.push_str("        }\n");
        output_functions.push_str("        false\n");
        output_functions.push_str("    }\n\n");

        // discovery has_acquired
        output_functions.push_str(format!("    pub fn has_acquired_{}(&self, {}{}) -> bool {{\n", n, id, suffix).as_str());
        output_functions.push_str("        // This should only be used internally if any change was found in the knowledges, therefore knowledges should yield a value.\n");
        output_functions.push_str("        if let Some(knowledges) = &self.knowledges {\n");
        output_functions.push_str(
            format!(
                "            return knowledges.knowledge_{}.iter().any(|e| {} && e.state == KnowledgeState::Acquired);\n",
                n, cmp
            )
            .as_str(),
        );
        output_functions.push_str("        }\n");
        output_functions.push_str("        false\n");
        output_functions.push_str("    }\n\n");

        // discovery discover
        output_functions.push_str(format!("    pub fn discover_{}(&mut self, ctx: &ReducerContext, {}{}) {{\n", n, id, suffix).as_str());
        if is_location {
            output_functions.push_str("{\n");
        } else {
            output_functions.push_str(format!("       if {} != 0 {{\n", id).as_str());
        }
        output_functions.push_str("            if self.knowledges.is_none() {\n");
        output_functions.push_str(
            format!(
                "                if Self::already_discovered_{}(ctx, self.player_entity_id, {}) {{\n",
                n, id
            )
            .as_str(),
        );
        output_functions.push_str("                    return;\n");
        output_functions.push_str("                }\n");
        output_functions.push_str("                self.initialize(ctx);\n");
        output_functions.push_str("            }\n");
        output_functions.push_str(format!("            if self.has_discovered_{}({}) {{\n", n, id).as_str());
        output_functions.push_str("                return;\n");
        output_functions.push_str("            }\n");
        output_functions.push_str("            let knowledges = self.knowledges.as_mut().unwrap();\n");
        output_functions.push_str(format!("            if !knowledges.knowledge_{}.iter().any(|e| {}) {{\n", n, cmp).as_str());
        output_functions.push_str(format!("                let knowledge_entry = {} {{\n", entry_type).as_str());
        if is_location {
            output_functions.push_str("                    location: coordinates,\n");
        } else {
            output_functions.push_str(format!("                    {}: {},\n", id_type, id).as_str());
        }
        output_functions.push_str("                    state: KnowledgeState::Discovered,\n");
        output_functions.push_str("                };\n");
        output_functions.push_str(format!("                knowledges.knowledge_{}.push(knowledge_entry);\n", n).as_str());
        if is_recipe {
            output_functions.push_str(format!("                self.discover_{}_recipe_components(ctx, {});\n", n, id).as_str());
        }
        output_functions.push_str("            };\n");
        output_functions.push_str("        }\n");
        output_functions.push_str("    }\n\n");

        // discovery acquire
        output_functions.push_str(format!("    pub fn acquire_{}(&mut self, ctx: &ReducerContext, {}{}) {{\n", n, id, suffix).as_str());
        if is_location {
            output_functions.push_str("{\n");
        } else {
            output_functions.push_str(format!("       if {} != 0 {{\n", id).as_str());
        }
        output_functions.push_str("            if self.knowledges.is_none() {\n");
        output_functions.push_str(
            format!(
                "                if Self::already_acquired_{}(ctx, self.player_entity_id, {}) {{\n",
                n, id
            )
            .as_str(),
        );
        output_functions.push_str("                    return;\n");
        output_functions.push_str("                }\n");
        output_functions.push_str("                self.initialize(ctx);\n");
        output_functions.push_str("            }\n");
        output_functions.push_str(format!("            if self.has_acquired_{}({}) {{\n", n, id).as_str());
        output_functions.push_str("                return;\n");
        output_functions.push_str("            }\n");
        output_functions.push_str(format!("            if !self.has_discovered_{}({}) {{\n", n, id).as_str());
        output_functions.push_str(format!("                self.discover_{}(ctx, {});\n", n, id).as_str());
        output_functions.push_str("            }\n");
        output_functions.push_str("            let knowledges = self.knowledges.as_mut().unwrap();\n");
        output_functions.push_str(
            format!(
                "            if let Some(entry) = knowledges.knowledge_{}.iter_mut().find(|e| {}) {{\n",
                n, cmp
            )
            .as_str(),
        );
        output_functions.push_str("                entry.state = KnowledgeState::Acquired;\n");
        output_functions.push_str("            }\n");
        if has_callback {
            output_functions.push_str(format!("            self.on_{}_acquired(ctx, {});\n", n, id).as_str());
        }

        if has_achievement {
            output_functions.push_str("            self.acquired_achievement = true;\n");
        }
        output_functions.push_str("        }\n");
        output_functions.push_str("    }\n\n");

        output_discovery.push_str(format!("    pub knowledge_{}: Vec<{}>,\n", n, entry_type).as_str());
        output_discovery.push_str(format!("    pub knowledge_{}_hash: i32,\n", n).as_str());

        output_init.push_str(
            format!(
                "            knowledge_{}: ctx.db.{}().entity_id().find(player_entity_id).unwrap().entries.clone(),\n",
                n,
                camel_to_snake(&k)
            )
            .as_str(),
        );
        output_init.push_str(
            format!(
                "            knowledge_{}_hash: Self::{}(&ctx.db.{}().entity_id().find(player_entity_id).unwrap().entries),\n",
                n,
                hash_function,
                camel_to_snake(&k)
            )
            .as_str(),
        );

        output_commit.push_str(
            format!(
                "        let knowledge_{}_hash = Self::{}(&knowledges.knowledge_{});\n",
                n, hash_function, n
            )
            .as_str(),
        );
        output_commit.push_str(format!("        if knowledge_{}_hash != knowledges.knowledge_{}_hash {{\n", n, n).as_str());
        output_commit.push_str(format!("            knowledges.knowledge_{}_hash = knowledge_{}_hash;\n", n, n).as_str());
        output_commit.push_str(
            format!(
                "            let mut knowledge = ctx.db.{}().entity_id().find(player_entity_id).unwrap().clone();\n",
                camel_to_snake(&k)
            )
            .as_str(),
        );
        output_commit.push_str(format!("            knowledge.entries = knowledges.knowledge_{}.clone();\n", n).as_str());
        // uncomment this line to see updated knowledge arrays on commit
        // output_commit.push_str(format!("            println!(\"{}: {{:?}}\", knowledge.entries);\n", n).as_str());
        output_commit.push_str(format!("            ctx.db.{}().entity_id().update(knowledge);\n", camel_to_snake(&k)).as_str());

        if n == "secondary" {
            output_commit.push_str("            PlayerState::collect_stats(ctx, self.player_entity_id);\n");
        }

        output_commit.push_str("        }\n");

        output_generate_knowledges.push_str(
            format!(
                "    if ctx.db.{}().try_insert({} {{ entries: Vec::new(), entity_id }}).is_err() {{}}\n",
                camel_to_snake(&k),
                k
            )
            .as_str(),
        );
    }

    output_generate_knowledges.push_str("}\n\n");
    output_includes.push_str("\n");

    output_discovery.push_str("}\n\n");
    output_init.push_str("        });\n");
    output_init.push_str("    }\n\n");

    output_commit.push_str("        if self.acquired_achievement {\n");
    output_commit.push_str("            self.acquired_achievement = false;\n");
    output_commit.push_str("            AchievementDesc::evaluate_all(self.player_entity_id);\n");
    output_commit.push_str("        }\n");
    output_commit.push_str("    }\n\n");
    output_functions.push_str("}\n");

    let discovery_str =
        output_discovery + output_generate_knowledges.as_str() + output_init.as_str() + output_commit.as_str() + output_functions.as_str();

    write_if_file_changed("src/game/discovery/autogen/_discovery.rs", discovery_str);
}

fn camel_to_snake(str: &String) -> String {
    let mut output = String::new();
    for c in str.chars() {
        if c.is_uppercase() {
            if String::is_empty(&output) {
                output.push_str(c.to_ascii_lowercase().to_string().as_str());
            } else {
                output.push_str(format!("_{}", c.to_ascii_lowercase()).as_str());
            }
        } else {
            output.push_str(c.to_string().as_str());
        }
    }
    output
}

fn main() {
    build_shared::main_shared();
    build_knowledge();
}
